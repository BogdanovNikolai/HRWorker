=== Дерево проекта ===

├── .env
    └── CONTENT:
        # === Redis Configuration ===
        REDIS_HOST=localhost
        REDIS_PORT=6379
        REDIS_DB=0
        REDIS_PASSWORD=
        REDIS_KEY_PREFIX=hh_app_
        
        # === PostgreSQL Configuration ===
        DB_NAME=HRWorker_database
        DB_USER=HRWorker_user
        DB_PASSWORD=12345678
        DB_HOST=localhost
        DB_PORT=1307
        
        # === HeadHunter API Tokens ===
        CLIENT_ID1=VN778607BRF23MVD9SUMP2VPQO3VHMTNFBS3NDJVFQ16BRB5QDF9HV934KMITQSE
        CLIENT_SECRET1=LQMOCIBAPIDP0C09T00ROOTQEI1PP7UD9OH4OH59DK4GMILR12C3HVA06TEV2G4R
        ACCESS_TOKEN1=USERMTU5U2VIH07RQGEDHOTSPM075IT8HOOESQPFADF5QHLO26SEKQFDS8I9MR5V
        REFRESH_TOKEN1=USERJ3CUPF2RED9CNKJLBVE9L2AH3JGBSEVOA1GPEE9P5GCO16D7HQUN3B6MB1PO
        REDIRECT_URI1=https://ya.ru
        ...
├── .env.example
├── .gitignore
├── README.md
    └── CONTENT:
        Справочники --> Интеграции --> Сценарии импорта
        
        Сценарии импорта
        
        Сценарий импорта позволяет загружать в программу:
        •Данные по объектам различных типов (структурные подразделения, кандидаты, вакансии и т.д.), экспортированные ранее из системы E-Staff Рекрутер, ипредставленные, как правило, во внутреннем XML-формате 
        •Данные по объектам различных типов, выгруженные ранее из внешней системыпроизвольного вида, и представленные в формате XML, CSV или Microsoft Excel (XLS)
        
        Импорт данных, экспортированных ранее из системы E-Staff Рекрутер:
        •Для создания карточки настроек нового сценария импорта откройте раздел Администрирование–>Справочники–>Интеграция–>Сценарииимпорта и нажмите кнопку Новый элемент.
        •Введите наименование сценария, установите переключатель на Импорт данных во внутреннем формате.
        •С помощью кнопки Просмотр укажите путь к исходнойпапке с данными для импорта.
        •Если необходимо загрузить не все объекты, а только новые (чтобыизбежать искажения внутренней базы устаревшими данными совпадающихобъектов), установите флажок Загружать только новые объекты.
        •Если необходимо загрузить не все объекты, а только объекты требуемоготипа, нажмите кнопку Добавить импортируемый объект ивыберитеиз списка нужный.
        
        Импорт данных в систему E-Staff Рекрутер из внешних систем:
        •Для создания карточки настроек нового сценария импорта откройте раздел Администрирование–>Справочники–>Интеграция–>Сценарииимпорта и нажмите кнопку Новый элемент.
        •Введите наименование сценария, установите переключатель на Импорт данных из других программ.
        •Выберите формат исходного файла. В случае выбора формата CSV или Microsoft Excel проверьте состояние флажка Первая строка файла содержит названияполей на соответствие первой строкиВаших файлов.
        •Если информация представлена в одном файле, тоустановитепереключатель на Импорт из одного файла, если внескольких - то на Импорт из папки с файлами.
        ...
├── [ai/]
│   ├── __init__.py
│       └── CONTENT:
│           """
│           Модуль `ai` предоставляет утилиты для оценки соответствия кандидата вакансии с помощью AI.
│           """
│           
│           from .main import AIEvaluator
│           
│           # Создаём экземпляр класса, чтобы его можно было использовать напрямую из `ai`
│           ai_evaluator = AIEvaluator()
│   └── main.py
│       └── CONTENT:
│           """
│           Модуль AI-оценки соответствия кандидата вакансии через DeepSeek API.
│           """
│           
│           import requests
│           import logging
│           import time
│           from typing import Tuple
│           from config import conf
│           
│           # Настройка логгера
│           logger = logging.getLogger(__name__)
│           
│           
│           class AIEvaluator:
│               """
│               Класс для оценки соответствия кандидата вакансии на основе анализа опыта работы и описания вакансии.
│           
│               Methods:
│                   evaluate_candidate_match: возвращает оценку соответствия кандидата вакансии.
│           ...
├── [api/]
│   └── [hh/]
│       ├── __init__.py
│           └── CONTENT:
│       └── main.py
│           └── CONTENT:
│               """
│               Модуль для взаимодействия с HeadHunter API.
│               Содержит класс HHApiClient, реализующий методы:
│               - Авторизация через OAuth2
│               - Получение резюме по ключевым словам
│               - Получение полных данных по отдельному резюме
│               - Получение вакансий компании
│               - Получение откликов по вакансии
│               - Проверка лимитов просмотра резюме
│               Все методы используют токен из config.conf.HH_ACCESS_TOKENS.
│               """
│               
│               import time
│               from datetime import datetime, timedelta
│               from urllib.parse import urlencode
│               import requests
│               import json
│               from typing import List, Dict, Any, Optional
│               from functools import wraps
│               from config import conf
│               ...
├── app.py
    └── CONTENT:
        """
        Модуль Flask-приложения для работы с резюме из HeadHunter.
        
        Содержит роуты:
        - /search — поиск резюме по ключевым словам
        - /vacancies — список вакансий нашей компании
        - /vacancies/<vacancy_id> — отклики по вакансии
        - /resumes/<task_id> — просмотр списка резюме
        - /export/<task_id> — выгрузка выбранных резюме в формате CSV/XLSX
        """
        
        import json
        from typing import List
        from flask import Flask, request, render_template, redirect, url_for, send_file, g
        from markupsafe import Markup
        from data_manager import dm
        from redis_manager import redis_manager
        from utils.logger import setup_logger
        from config import conf
        from data_manager.exporters import CSVExporter, XLSXExporter
        ...
├── areas_cache.json
    └── CONTENT:
        [
          {
            "id": "113",
            "parent_id": null,
            "name": "Россия",
            "areas": [
              {
                "id": "1620",
                "parent_id": "113",
                "name": "Республика Марий Эл",
                "areas": [
                  {
                    "id": "4228",
                    "parent_id": "1620",
                    "name": "Виловатово",
                    "areas": []
                  },
                  {
                    "id": "1621",
                    "parent_id": "1620",
        ...
├── build_tree.py
    └── CONTENT:
        import os
        from pathlib import Path
        
        # === Настройки ===
        PROJECT_ROOT = "."  # корень проекта (текущая директория)
        OUTPUT_FILE = "project_tree.txt"  # выходной файл
        
        # Какие файлы читать (расширения)
        INCLUDE_EXTENSIONS = [".py", ".txt", ".md", ".env", ".json"]
        
        # Какие директории игнорировать
        IGNORE_DIRS = {
            "__pycache__",
            ".git",
            ".venv",
            "venv",
            "__pycache__",
            "migrations",
            ".pytest_cache",
            "env"
        ...
├── [config/]
│   ├── __init__.py
│       └── CONTENT:
│           from .main import Config
│           
│           conf = Config()
│   └── main.py
│       └── CONTENT:
│           """
│           Модуль для загрузки и предоставления конфигурационных данных из .env файла.
│           
│           Содержит класс Config, который предоставляет доступ ко всем переменным окружения,
│           используемым в приложении.
│           """
│           
│           import os
│           from dotenv import load_dotenv
│           from typing import List, Optional
│           
│           load_dotenv()
│           
│           class Config:
│               """
│               Класс конфигурации приложения.
│           
│               Предоставляет доступ к переменным окружения, используемым в приложении.
│               """
│           
│           ...
├── [data_manager/]
│   ├── __init__.py
│       └── CONTENT:
│           from .main import DataManager
│           
│           dm = DataManager()
│   ├── exporters.py
│       └── CONTENT:
│           """
│           Модуль экспорта данных.
│           
│           Содержит классы для выгрузки резюме в форматы CSV/XLSX.
│           """
│           
│           import csv
│           import json
│           from typing import List, Dict, Any, Optional
│           from pathlib import Path
│           from openpyxl import Workbook
│           from openpyxl.styles import Font, Alignment
│           from redis_manager import redis_manager
│           from data_manager.resume_processor import ResumeProcessor
│           from database.repository import ResumeRepository
│           from database.session import get_db
│           from utils.logger import setup_logger
│           
│           
│           logger = setup_logger(__name__)
│           ...
│   ├── main.py
│       └── CONTENT:
│           """
│           Основной модуль data_manager.
│           
│           Содержит класс DataManager — точку входа для всех операций с данными.
│           """
│           
│           from typing import List, Dict, Any, Optional, Tuple
│           from api.hh.main import HHApiClient
│           from data_manager.resume_processor import ResumeProcessor
│           from data_manager.search_engine import SearchEngine
│           from database.repository import ResumeRepository
│           from redis_manager import RedisManager
│           from database.session import get_db
│           from utils.logger import setup_logger
│           from threading import Thread
│           from data_manager.task_tracker import TaskTracker
│           
│           logger = setup_logger()
│           
│           
│           ...
│   ├── resume_processor.py
│       └── CONTENT:
│           from typing import Dict, Any, List, Optional
│           from datetime import datetime
│           import json
│           import uuid
│           from utils.logger import setup_logger
│           from redis_manager import redis_manager
│           
│           
│           logger = setup_logger(__name__)
│           
│           
│           class ResumeProcessor:
│               """
│               Обрабатывает сырой JSON от HeadHunter и формирует словарь с ключевыми полями.
│           
│               Attributes:
│                   raw_data (dict): Сырые данные резюме из API HH.
│                   use_cache (bool): Использовать ли кэширование через Redis.
│                   cache_ttl (int): Время жизни кэша в секундах.
│               """
│           ...
│   ├── search_engine.py
│       └── CONTENT:
│           """
│           Модуль поиска резюме по ключевым словам.
│           
│           Содержит класс SearchEngine для работы с фильтрами, TTL проверкой и Redis-кэшированием.
│           """
│           
│           import json
│           from typing import List, Dict, Any, Optional
│           from datetime import datetime, timedelta
│           
│           from database.repository import ResumeRepository
│           from database.session import get_db
│           from data_manager.resume_processor import ResumeProcessor
│           from api.hh.main import HHApiClient
│           from utils.logger import setup_logger
│           from redis_manager import redis_manager
│           from config import conf
│           
│           logger = setup_logger(__name__)
│           
│           ...
│   └── task_tracker.py
│       └── CONTENT:
│           from redis_manager import RedisManager
│           from utils.logger import setup_logger
│           
│           logger = setup_logger(__name__)
│           
│           class TaskTracker:
│               def __init__(self):
│                   self.redis = RedisManager()
│           
│               def create_task(self, description: str = "", resume_ids: list = None) -> str:
│                   """Создаёт новую задачу с начальным прогрессом."""
│                   return self.redis.create_task(resume_ids or [], description)
│           
│               def update_progress(self, task_id: str, progress: int, status: str = "in_progress") -> None:
│                   """Обновляет прогресс выполнения задачи."""
│                   self.redis.update_task_progress(task_id, progress, status)
│           
│               def get_progress(self, task_id: str) -> dict:
│                   """Возвращает текущий прогресс и статус задачи."""
│                   task_data = self.redis.get_task_data(task_id)
│           ...
├── [database/]
│   ├── __init__.py
│       └── CONTENT:
│           from .models import Resume
│           from .repository import ResumeRepository
│           from .session import engine, Base, get_db
│           
│           def init_db():
│               """
│               Создаёт все таблицы в БД, если их ещё нет.
│               """
│               Base.metadata.create_all(bind=engine)
│   ├── models.py
│       └── CONTENT:
│           """
│           Модуль содержит определения ORM-моделей для взаимодействия с базой данных.
│           
│           В текущей реализации представлена одна модель: Resume.
│           """
│           
│           from sqlalchemy import Column, Integer, String, Text, DateTime, JSON
│           from database.session import Base
│           from datetime import datetime
│           
│           
│           class Resume(Base):
│               __tablename__ = "resumes"
│           
│               id = Column(String(100), primary_key=True, index=True)
│               first_name = Column(String(128))
│               middle_name = Column(String(128))
│               last_name = Column(String(128))
│               title = Column(String(255))
│               age = Column(Integer)
│           ...
│   ├── repository.py
│       └── CONTENT:
│           """
│           Модуль содержит функции для работы с данными в базе данных.
│           
│           Предоставляет CRUD-операции над моделью Resume.
│           """
│           
│           import json
│           from typing import Optional, List
│           from database.models import Resume
│           from sqlalchemy.orm import Session
│           
│           
│           class ResumeRepository:
│               """
│               Репозиторий для работы с резюме в базе данных.
│           
│               Methods:
│                   get_by_link(db, link): Возвращает резюме по ссылке.
│                   create_resume(db, resume_data): Добавляет новое резюме в БД.
│                   get_all_resumes(db, skip, limit): Возвращает список резюме с пагинацией.
│           ...
│   └── session.py
│       └── CONTENT:
│           """
│           Модуль для управления сессиями SQLAlchemy.
│           
│           Содержит engine, базовый класс для моделей и фабрику сессий.
│           """
│           
│           from sqlalchemy import create_engine
│           from sqlalchemy.ext.declarative import declarative_base
│           from sqlalchemy.orm import sessionmaker
│           from config import conf
│           
│           # Прямой путь к БД (временно, для теста)
│           db_url = "postgresql://HRWorker_user:12345678@localhost:5432/HRWorker_database"
│           
│           engine = create_engine(db_url, pool_pre_ping=True)
│           SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
│           Base = declarative_base()
│           
│           
│           def get_db():
│           ...
├── [docs/]
│   ├── docs.md
│       └── CONTENT:
│   └── generate_docs.py
│       └── CONTENT:
├── [helpers/]
│   ├── __init__.py
│       └── CONTENT:
│           from .main import AreaManager
│           import os
│           
│           # Путь к файлу с регионами (относительно корня проекта)
│           AREAS_FILE_PATH = os.path.join(os.path.dirname(os.path.dirname(__file__)), "areas_cache.json")
│           
│           area_manager = AreaManager(AREAS_FILE_PATH)
│           area_manager.load_areas()
│   └── main.py
│       └── CONTENT:
│           import json
│           import os
│           
│           def collect_areas(data):
│               """
│               Рекурсивно собирает все регионы в плоский список {'id', 'name'}
│               """
│               areas = []
│           
│               def recursive_collect(items):
│                   for item in items:
│                       areas.append({
│                           'id': item['id'],
│                           'name': item['name']
│                       })
│                       if item.get('areas'):
│                           recursive_collect(item['areas'])
│           
│               recursive_collect(data)
│               return areas
│           ...
├── main.py
    └── CONTENT:
        """
        Точка входа приложения.
        
        Запуск Flask-сервера и инициализация системы.
        """
        
        import os
        from app import app
        from config import conf
        from database import init_db
        
        
        if __name__ == "__main__":
            init_db()
        
            # host = conf.HH_HOST
            # port = conf.HH_PORT
            # debug = conf.DEBUG_MODE
        
            print(f"=== Запуск сервера ===")
        ...
├── merge_py_html.py
    └── CONTENT:
        import os
        
        # Расширения, которые нужно склеить
        INCLUDE_EXTENSIONS = {".py", ".html"}
        
        # Файлы и папки, которые нужно игнорировать
        IGNORE_ITEMS = {
            ".git",
            "__pycache__",
            ".env",
            "venv",
            "env",
            ".gitignore",
            ".pyc",
            "__pycache__",
            ".DS_Store",
            ".pytest_cache"
        }
        
        def should_ignore(name):
        ...
├── [output/]
│   ├── resumes_1d8967cc-8483-41dc-8b99-9d25702db1a7.xlsx
│   ├── resumes_2dbb1899-d87b-425f-a4fe-f07731a31ad6.xlsx
│   ├── resumes_2eaf5858-d1e9-486f-984f-32ee37022b6f.xlsx
│   ├── resumes_6a934493-6895-480b-8943-ea01a057e58b.csv
│   ├── resumes_6a934493-6895-480b-8943-ea01a057e58b.xlsx
│   ├── resumes_8d30fa23-4379-4df4-ac82-dd671e9539c2.xlsx
│   ├── resumes_c6b0ce65-593a-4555-b565-a8c289cb4c13.csv
│   ├── resumes_cf150384-2f57-4330-a87e-bf1215699526.xlsx
│   └── resumes_d0f8f665-1d8c-420b-bf94-60fb6dc1dffa.xlsx
├── output.txt
    └── CONTENT:
        📁 Структура проекта:
        
        ./
        ├── README.md
        ├── ai/
        │   ├── main.py
        ├── api/
        │   └── hh/
        │       ├── main.py
        ├── app.log
        ├── app.py
        ├── areas_cache.json
        ├── build_tree.py
        ├── config/
        │   ├── main.py
        ├── data_manager/
        │   ├── exporters.py
        │   ├── main.py
        │   └── resume_processor.py
        │   ├── search_engine.py
        ...
├── project_tree.txt
    └── CONTENT:
        === Дерево проекта ===
        
        ├── .env
            └── CONTENT:
        ├── .env.example
        ├── .gitignore
        ├── README.md
            └── CONTENT:
        ├── [ai/]
        │   ├── __init__.py
        │       └── CONTENT:
        │   └── main.py
        │       └── CONTENT:
        ├── [api/]
        │   └── [hh/]
        │       ├── __init__.py
        │           └── CONTENT:
        │       └── main.py
        │           └── CONTENT:
        ├── app.py
        ...
├── [redis_manager/]
│   ├── __init__.py
│       └── CONTENT:
│           from .main import RedisManager
│           
│           redis_manager = RedisManager()
│   └── main.py
│       └── CONTENT:
│           """
│           Модуль для работы с Redis.
│           
│           Содержит класс RedisManager для управления задачами и временными данными.
│           """
│           
│           from datetime import datetime
│           import redis
│           import json
│           import uuid
│           from typing import List, Optional
│           from config import conf
│           from utils.logger import setup_logger
│           
│           
│           logger = setup_logger(__name__)
│           
│           
│           class RedisManager:
│               """
│           ...
├── requirements.txt
    └── CONTENT:
        b l i n k e r = = 1 . 9 . 0 
         
         c e r t i f i = = 2 0 2 5 . 6 . 1 5 
         
         c h a r s e t - n o r m a l i z e r = = 3 . 4 . 2 
         
         c l i c k = = 8 . 2 . 1 
         
         c o l o r a m a = = 0 . 4 . 6 
         
         d o t e n v = = 0 . 9 . 9 
         
         e t _ x m l f i l e = = 2 . 0 . 0 
         
         F l a s k = = 3 . 1 . 1 
         
         g r e e n l e t = = 3 . 2 . 3 
         
         i d n a = = 3 . 1 0 
         
        ...
├── [templates/]
│   ├── base.html
│   ├── index.html
│   ├── resume_list.html
│   ├── search.html
│   ├── task_progress.html
│   └── vacancies.html
├── [tests/]
└── [utils/]
    ├── __init__.py
        └── CONTENT:
            from .logger import setup_logger
    └── logger.py
        └── CONTENT:
            """
            Модуль для настройки централизованного логгера.
            
            Содержит функцию setup_logger(), которая настраивает логгер с выводом как в консоль,
            так и в файл. Уровень логирования берётся из переменной окружения LOG_LEVEL.
            """
            
            import logging
            import os
            from logging.handlers import RotatingFileHandler
            from typing import Optional
            
            def setup_logger(name: str = __name__, log_file: Optional[str] = None, level: str = "INFO") -> logging.Logger:
                """
                Настраивает и возвращает логгер с указанными параметрами.
            
                Args:
                    name (str): Имя логгера. Обычно используется __name__ модуля.
                    log_file (Optional[str]): Путь к файлу лога. Если не указан, используется значение из env.
                    level (str): Уровень логирования. Например: DEBUG, INFO, WARNING, ERROR, CRITICAL.
            ...